<?php
// $Id$

/**
 * @file
 *   Provides a file attachment search implementation for use with the Apache Solr module
 */

/**
 * Implementation of hook_menu().
 */
function apachesolr_attachments_menu() {
  $items = array();
  $items['admin/settings/apachesolr/attachments'] = array(
    'title' => 'File attachments',
    'description' => 'Administer Apache Solr Attachments.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('apachesolr_attachments_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Displays the Attachment Settings Form.
*/
function apachesolr_attachments_settings() {

  $form['apachesolr_attachments_tika_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Tika directory path'),
    '#size' => 80,
    '#maxlength' => 100,
    '#description' =>  t("The full path to tika directory.  All library jars must be in the same directory."),
    '#default_value' => variable_get('apachesolr_attachments_tika_path', ''),
  );
  $form['apachesolr_attachments_tika_jar'] = array(
    '#type' => 'textfield',
    '#title' => t('Tika jar file'),
    '#size' => 20,
    '#description' =>  t("The name of the tika jar file, e.g. tika-0.3.jar."),
    '#default_value' => variable_get('apachesolr_attachments_tika_jar', 'tika-0.3.jar'),
  );
  $form = system_settings_form($form);
  $form['#validate'][] = 'apachesolr_attachments_settings_validate';
  return $form;
}

function apachesolr_attachments_settings_validate($form, &$form_state) {
  $path = realpath($form_state['values']['apachesolr_attachments_tika_path']);
  if (!file_exists($path . '/' . $form_state['values']['apachesolr_attachments_tika_jar'])) {
    form_set_error('apachesolr_attachments_tika_path', t('Tika jar file not found at this path.'));
  }
}

/**
 * Implementation of hook_search().
 */
function apachesolr_attachments_search($op = 'search', $keys = NULL) {

  switch ($op) {
    case 'name':
      return ''; // We dont want a tab
    case 'reset':
      apachesolr_clear_last_index('apachesolr_attachments');
      return;
    case 'status':
      // TODO: Figure out a way to know how many actual files are left to update.
      return apachesolr_index_status('apachesolr_attachments');
    case 'search':
      return array();
  }
}

/**
 * Hook is called by search.module to add things to the search index.
 * In our case we will search content types and add any CCK type that
 * is a file type that we know how to parse and any uploaded file
 * attachments.
 */
function apachesolr_attachments_update_index() {
  if(!variable_get('apachesolr_attachments_tika_path', '')) {
    return;
  }
  $start = time();
  $cron_try = variable_get('apachesolr_attachements_cron_try', 20);
  $cron_limit = variable_get('apachesolr_attachments_cron_limit', 100);
  $cron_time_limit = variable_get('apachesolr_attachements_cron_time_limit', 15);
  $num_tried = 0;
  do {
    $rows = apachesolr_get_nodes_to_index('apachesolr_attachments', $cron_try);
    $success = apachesolr_index_nodes($rows,  'apachesolr_attachments', 'apachesolr_attachments_add_documents');
    $num_tried += $cron_try;
  } while ($success && ($num_tried < $cron_limit) && (time() - $start < $cron_time_limit));
}

/**
 * Callback for apachesolr_index_nodes().
 *
 * Adds a document for each indexable file attachment for the given node ID.
 */
function apachesolr_attachments_add_documents(&$documents, $nid) {
  $node = node_load($nid, NULL, TRUE);
  if (!empty($node->nid)) {

    $hash = apachesolr_site_hash();

    // Since there is no notification for an attachment being unassociated with a
    // node (but that action will trigger it to be indexed again), we check for
    // fids that were added before but no longer present on this node.

    $fids = array();
    $result = db_query("SELECT fid FROM {apachesolr_attachments_files} WHERE nid = %d", $node->nid);
    while ($row = db_fetch_array($result)) {
      $fids[$row['fid']] = $row['fid'];
    }

    $files = _asa_get_indexable_files($node);

    // Find deleted files.
    $missing_fids = array_diff_key($fids, $files);
    if ($missing_fids) {
      db_query("UPDATE {apachesolr_attachments_files} SET removed = 1 WHERE fid IN (". db_placeholders($missing_fids) .")", $missing_fids);
    }
    $new_files = array_diff_key($files, $fids);
    // Add new files.
    foreach ($new_files as $file) {
      db_query("INSERT INTO {apachesolr_attachments_files} (fid, nid, removed) VALUES (%d, %d, 0)", $file->fid, $node->nid);
    }
    foreach ($files as $file) {
      $text = _asa_get_attachment_text($file);
       // Strip bad control characters. Do we need to make a hook for text cleanup?
      $text = iconv("UTF-8", "UTF-8//IGNORE", $text);
      $text = trim(apachesolr_clean_text($text));

      if ($text) {
        $document = new Apache_Solr_Document();
        // A single file might be attached to multiple nodes.
        $document->id = apachesolr_document_id($file->fid .'-'. $node->nid, 'file');
        $document->url = file_create_url($file->filepath);
        $document->path = $file->filepath;
        $document->hash = $hash;
        $document->site = url(NULL, array('absolute' => TRUE));
        $document->nid = $node->nid;
        $document->title = $file->filename;
        $document->created = apachesolr_date_iso($file->timestamp);
        $document->changed = $document->created;
        $document->status = $node->status;
        $document->sticky = $node->sticky;
        $document->promote = $node->promote;
        $document->uid = $node->uid;
        $document->name = apachesolr_strip_ctl_chars($node->name);
        $document->body = apachesolr_clean_text($file->description) .' '. $text;

        $document->bs_file = TRUE;
        $document->ss_filemime = $file->filemime;
        $document->ss_file_node_title = apachesolr_clean_text($node->title);
        $document->ss_file_node_url = url('node/' . $node->nid, array('absolute' => TRUE));

        apachesolr_add_taxonomy_to_document($document, $node);

        if (module_exists('apachesolr_nodeaccess')) {
          apachesolr_nodeaccess_apachesolr_update_index($document, $node);
        }
        drupal_alter('apachesolr_attachment_index', $document, $node, $file);

        $documents[] = $document;
      }
      else {
        watchdog('Apache Solr Attachments', t('Could not extract any indexable text from %filepath'), array('%filepath' => $file->filepath), WATCHDOG_WARNING);
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * For a delete: mark all associated attachments as removed.
 */
function apachesolr_attachments_nodeapi($node, $op) {

  switch ($op) {
    case 'delete':
      _asa_remove_attachments_from_index($node->nid);
      // Mark attachments for later re-deletion in case the query fails.
      db_query("UPDATE {apachesolr_attachments_files} SET removed = 1 WHERE nid = %d", $node->nid);
      break;
  }
}

/**
 * Implementation of hook_cron().
 *
 * Delete all removed attachments from the Solr store.
 */
function apachesolr_attachments_cron() {
  try {
    $solr = apachesolr_get_solr();
    $result = db_query("SELECT fid, nid FROM {apachesolr_attachments_files} WHERE removed = 1");
    $ids = array();
    $fids = array();
    while ($file = db_fetch_object($result)) {
      $ids[] = 'id:'. apachesolr_document_id($file->fid .'-'. $file->nid, 'file');
      $fids[] = $file->fid;
    }
    if ($ids) {
      $solr->deleteByQuery(implode(' OR ', $ids));
      $solr->commit();
      db_query("DELETE FROM {apachesolr_attachments_files} WHERE fid IN (". db_placeholders($fids) .")", $fids);
    }
  }
  catch (Exception $e) {
    watchdog('Apache Solr Attachments', $e->getMessage() . ' in apachesolr_attachments_cron', NULL, WATCHDOG_ERROR);
  }
}

/**
 * Implementation of hook_apachesolr_modify_query().
 */
function apachesolr_attachments_apachesolr_modify_query(&$query, &$params, $caller) {
  // Fetch the extra file data on searches.
  if ($caller == 'apachesolr_search') {
    $params['fl'] .= ',ss_filemime,ss_file_node_title,ss_file_node_url';
  }
  elseif ($caller == 'apachesolr_mlt') {
    // Exclude files from MLT results.
    $query->add_filter('bs_file', 'true', TRUE);
  }
}

/**
 * Implementation of hook_apachesolr_process_results().
 *
 * When using the Apache Solr search module, everything is treated as a node
 * and as such values like the link and type won't be configured correctly if
 * it is a file attachement. We override such values here as needed.
 */
function apachesolr_attachments_apachesolr_process_results(&$results) {

  foreach ($results as &$item) {
    if (isset($item['node']->ss_filemime)) {
      $nid = $item['node']->nid;
      $item['link'] = file_create_url($item['node']->path);
      $node_link = t('<em>attached to:</em> !node_link', array('!node_link' => l($item['node']->ss_file_node_title, 'node/'. $nid)));
      $icon = theme('filefield_icon', array('filemime' => $item['node']->ss_filemime));
      $file_type = t('!icon @filemime', array('@filemime' => $item['node']->ss_filemime, '!icon' => $icon));
      $item['snippet'] .= '<div>' . $file_type .' '. $node_link . '</div>';
      $item['extra'] = array();
      $item['type'] = t('File attachment');
    }
  }
}

/**
 * Return all non-indexed file attachments for a particular node
 */
function _asa_get_indexable_files($node) {
  $files = array();

  if(!empty($node->files)) {
    $files = $node->files;
  }

  $fields = _asa_get_cck_file_fields();
  foreach ($fields as $field) {
    if(!empty($node->$field)) {
      $files = array_merge($files, $node->$field);
    }
  }
  $file_list = array();
  foreach ($files as $file) {
    // Some are arrays others are objects, treat them all as objects
    $file = (object) $file;
    // Some filefield-enabled nodes show up with an emtpy file array.
    if (!empty($file->fid)) {
      if (isset($file->data['description']) && !isset($file->description)) {
        $file->description = $file->data['description'];
      }
      $file_list[$file->fid] = $file;
    }
  }
  return $file_list;
}

/**
 * Return all CCK fields that are of type 'file'
 */
function _asa_get_cck_file_fields() {
  $file_fields = array();
  if(module_exists('filefield')) {
    $fields = content_fields();
    foreach($fields as $key => $values){
      if($values['type'] == 'filefield') {
        $file_fields[] = $key;
      }
    }
  }
  return $file_fields;
}

/**
 * Parse the attachment getting just the raw text.
 */
function _asa_get_attachment_text($file) {
  // Any down-side to using realpath()?
  $filepath = realpath('./' . $file->filepath);

  // No need to use java for plain text files.
  if ($file->filemime == 'text/plain' || $file->filemime == 'text/x-diff') {
    // TODO - try to detect encoding and convert to UTF-8.
    return file_get_contents($filepath);
  }

  $tika_path = realpath(variable_get('apachesolr_attachments_tika_path', ''));

  $tika = $tika_path .'/'. variable_get('apachesolr_attachments_tika_jar', 'tika-0.3.jar');

  $java = variable_get('apachesolr_attachments_java', 'java');
  $cmd = escapeshellcmd($java .' -cp '. $tika_path .' -jar '. $tika .' -t "'. $filepath .'"');

  // Add a work-around for a MAMP bug.
  if (strpos(ini_get('extension_dir'), 'MAMP/')) {
    $cmd = 'export DYLD_LIBRARY_PATH=""; '. $cmd;
  }
  $text = shell_exec($cmd);

  return $text;
}

/**
 * For a particular node id, remove all file attachments from the solr index.
 */
function _asa_remove_attachments_from_index($nid) {
  try {
    $solr = apachesolr_get_solr();
    $solr->deleteByQuery("nid:{$nid} AND bs_file:true AND hash:". apachesolr_site_hash());
    $solr->commit();
  }
  catch (Exception $e) {
    watchdog('Apache Solr Attachments', $e->getMessage(), NULL, WATCHDOG_ERROR);
  }
}

