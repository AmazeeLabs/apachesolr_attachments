<?php
// $Id$

/**
 * @file
 *   Provides a file attachment search implementation for use with the Apache Solr module
 */

define (EXTRACTING_SERVLET, 'extract/tika');

/**
 * Implementation of hook_menu().
 */
function apachesolr_attachments_menu() {
  $items = array();
  $items['admin/settings/apachesolr/attachments'] = array(
    'title' => 'File attachments',
    'description' => 'Administer Apache Solr Attachments.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('apachesolr_attachments_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

function apachesolr_attachments_default_excluded() {
  $default = array('aif', 'art', 'avi', 'bmp', 'gif', 'ico', 'jpg', 'mov', 'mp3', 'mp4', 'mpg', 'oga', 'ogv', 'png', 'psd', 'ra', 'ram', 'rgb', 'tif',);
  return $default;
}

/**
 * Displays the Attachment Settings Form.
*/
function apachesolr_attachments_settings() {
  $default = implode(' ', apachesolr_attachments_default_excluded());
  $form['apachesolr_attachment_excluded_extensions'] = array(
    '#type' => 'textfield',
    '#title' => t('Excluded file extensions'),
    '#default_value' => variable_get('apachesolr_attachment_excluded_extensions', $default),
    '#size' => 80,
    '#maxlength' => 255,
    '#description' => t('File extensions that are excluded from indexing. Separate extensions with a space and do not include the leading dot. Extensions are internally mapped to a MIME type, so it is not necessary to put variations that map to the same type (e.g. tif is sufficient for tif and tiff)'),
  );
  $form['apachesolr_attachments_exclude_types'] = array(
    '#type' => 'radios',
    '#title' => t('Exclude files attached to a node of a type excluded by Apache Solr Search'),
    '#options' => array('0' => t('No'), '1' => t('Yes')),
    '#default_value' => variable_get('apachesolr_attachments_exclude_types', 1),
  );
  $form['apachesolr_attachment_extract_using'] = array(
    '#type' => 'radios',
    '#title' => t('Extract using'),
    '#options' => array(
      'tika' => t('Tika (local java application)'),
      'solr' => t('Solr (remote server)'),
    ),
    '#description' =>  t("Extraction will be faster if run locally using tika."),
    '#default_value' => variable_get('apachesolr_attachment_extract_using', 'tika'),
  );
  $form['apachesolr_attachments_tika_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Tika directory path'),
    '#size' => 80,
    '#maxlength' => 100,
    '#description' =>  t("The full path to tika directory.  All library jars must be in the same directory."),
    '#default_value' => variable_get('apachesolr_attachments_tika_path', ''),
  );
  $form['apachesolr_attachments_tika_jar'] = array(
    '#type' => 'textfield',
    '#title' => t('Tika jar file'),
    '#size' => 20,
    '#description' =>  t("The name of the tika CLI application jar file, e.g. tika-0.3.jar or tika-app-0.4.jar."),
    '#default_value' => variable_get('apachesolr_attachments_tika_jar', 'tika-0.3.jar'),
  );

  $form = system_settings_form($form);
  $form['#validate'][] = 'apachesolr_attachments_settings_validate';
  $form['#submit'][] = 'apachesolr_attachments_settings_submit';
  return $form;
}

function apachesolr_attachments_settings_validate($form, &$form_state) {
  if ($form_state['values']['apachesolr_attachment_extract_using'] == 'tika') {
    $path = realpath($form_state['values']['apachesolr_attachments_tika_path']);
    if (!file_exists($path . '/' . $form_state['values']['apachesolr_attachments_tika_jar'])) {
      form_set_error('apachesolr_attachments_tika_path', t('Tika jar file not found at this path.'));
    }
  }
}

function apachesolr_attachments_settings_submit($form, &$form_state) {
  // Delete this so it's rebuilt.
  variable_del('apachesolr_attachment_excluded_mime');
  drupal_set_message(t('If you changed the allowed file extensions, you may need to delete and re-index all attachements.'));
}

function apachesolr_attachments_allowed_mime($filemime) {

  $excluded = variable_get('apachesolr_attachment_excluded_mime', FALSE);
  if ($excluded === FALSE) {
    // Build the list of excluded MIME types.
    $excluded = array();
    $extensions = variable_get('apachesolr_attachment_excluded_extensions', FALSE);
    if ($extensions !== FALSE) {
      $extensions = explode(' ', $extensions);
    }
    else {
      $extensions = apachesolr_attachments_default_excluded();
    }
    foreach ($extensions as $ext) {
      $ext = trim($ext);
      if ($ext) {
        $mime = file_get_mimetype('dummy.' . $ext);
        $excluded[$mime] = 1;
      }
    }
    variable_set('apachesolr_attachment_excluded_mime', $excluded);
  }
  return empty($excluded[$filemime]);
}

/**
 * Implementation of hook_help().
 */
function apachesolr_attachments_help($section) {
  switch ($section) {
    case 'admin/settings/apachesolr/index':
      if (!variable_get('apachesolr_read_only', 0)) {
        $remaining = 0;
        $total = 0;
        // Collect the stats
        $status = apachesolr_attachments_search('status');
        $remaining += $status['remaining'];
        $total += $status['total'];
        return t('<br />There @items remaining to be examined for attachments out of @total total.', array(
          '@items' => format_plural($remaining, t('is 1 post'), t('are @count posts')),
          '@total' => $total,
        ));
      }
      break;
  }
}

/**
 * Implementation of hook_search().
 */
function apachesolr_attachments_search($op = 'search', $keys = NULL) {

  switch ($op) {
    case 'name':
      return ''; // We dont want a tab
    case 'reset':
      apachesolr_clear_last_index('apachesolr_attachments');
      return;
    case 'status':
      // TODO: Figure out a way to know how many actual files are left to update.
      return apachesolr_index_status('apachesolr_attachments');
    case 'search':
      return array();
  }
}

/**
 * Implementation of hook_apachesolr_types_exclude().
 */
function apachesolr_attachments_apachesolr_types_exclude($namespace) {
  if ($namespace == 'apachesolr_attachments') {
    if (variable_get('apachesolr_attachments_exclude_types', 1)) {
      $excluded_types = variable_get('apachesolr_search_excluded_types', array());
      return array_filter($excluded_types);
    }
    return array();
  }
}

/**
 * Hook is called by search.module to add things to the search index.
 * In our case we will search content types and add any CCK type that
 * is a file type that we know how to parse and any uploaded file
 * attachments.
 */
function apachesolr_attachments_update_index() {
  if(!variable_get('apachesolr_attachments_tika_path', '')) {
    return;
  }
  $start = time();
  $cron_try = variable_get('apachesolr_attachements_cron_try', 20);
  $cron_limit = variable_get('apachesolr_attachments_cron_limit', 100);
  $cron_time_limit = variable_get('apachesolr_attachements_cron_time_limit', 15);
  $num_tried = 0;
  do {
    $rows = apachesolr_get_nodes_to_index('apachesolr_attachments', $cron_try);
    $success = apachesolr_index_nodes($rows, 'apachesolr_attachments', 'apachesolr_attachments_add_documents');
    $num_tried += $cron_try;
  } while ($success && ($num_tried < $cron_limit) && (time() - $start < $cron_time_limit));
}

/**
 * Callback for apachesolr_index_nodes().
 *
 * Adds a document for each indexable file attachment for the given node ID.
 */
function apachesolr_attachments_add_documents(&$documents, $nid) {
  $node = node_load($nid, NULL, TRUE);
  if (!empty($node->nid)) {

    $hash = apachesolr_site_hash();

    // Since there is no notification for an attachment being unassociated with a
    // node (but that action will trigger it to be indexed again), we check for
    // fids that were added before but no longer present on this node.

    $fids = array();
    $result = db_query("SELECT fid FROM {apachesolr_attachments_files} WHERE nid = %d", $node->nid);
    while ($row = db_fetch_array($result)) {
      $fids[$row['fid']] = $row['fid'];
    }

    $files = _asa_get_indexable_files($node);

    // Find deleted files.
    $missing_fids = array_diff_key($fids, $files);
    if ($missing_fids) {
      db_query("UPDATE {apachesolr_attachments_files} SET removed = 1 WHERE fid IN (". db_placeholders($missing_fids) .")", $missing_fids);
    }
    $new_files = array_diff_key($files, $fids);
    // Add new files.
    foreach ($new_files as $file) {
      db_query("INSERT INTO {apachesolr_attachments_files} (fid, nid, removed, sha1) VALUES (%d, %d, 0, '')", $file->fid, $node->nid);
    }
    foreach ($files as $file) {
      $text = _asa_get_attachment_text($file);

      if ($text) {
        $document = new Apache_Solr_Document();
        // A single file might be attached to multiple nodes.
        $document->id = apachesolr_document_id($file->fid .'-'. $node->nid, 'file');
        $document->url = file_create_url($file->filepath);
        $document->path = $file->filepath;
        $document->hash = $hash;
        $document->site = url(NULL, array('absolute' => TRUE));
        $document->nid = $node->nid;
        $document->title = $file->filename;
        $document->created = apachesolr_date_iso($file->timestamp);
        $document->changed = $document->created;
        $document->status = $node->status;
        $document->sticky = $node->sticky;
        $document->promote = $node->promote;
        $document->uid = $node->uid;
        $document->name = apachesolr_strip_ctl_chars($node->name);
        $document->body = apachesolr_clean_text($file->description) .' '. $text;

        $document->bs_file = TRUE;
        $document->ss_filemime = $file->filemime;
        $document->ss_file_node_title = apachesolr_clean_text($node->title);
        $document->ss_file_node_url = url('node/' . $node->nid, array('absolute' => TRUE));

        apachesolr_add_taxonomy_to_document($document, $node);

        if (module_exists('apachesolr_nodeaccess')) {
          apachesolr_nodeaccess_apachesolr_update_index($document, $node);
        }
        drupal_alter('apachesolr_attachment_index', $document, $node, $file);

        $documents[] = $document;
      }
      else {
        watchdog('Apache Solr Attachments', t('Could not extract any indexable text from %filepath'), array('%filepath' => $file->filepath), WATCHDOG_WARNING);
      }
    }
  }
}

/**
 * Implementation of hook_nodeapi().
 *
 * For a delete: mark all associated attachments as removed.
 */
function apachesolr_attachments_nodeapi($node, $op) {

  switch ($op) {
    case 'delete':
      _asa_remove_attachments_from_index($node->nid);
      // Mark attachments for later re-deletion in case the query fails.
      db_query("UPDATE {apachesolr_attachments_files} SET removed = 1 WHERE nid = %d", $node->nid);
      break;
  }
}

/**
 * Implementation of hook_cron().
 *
 * Delete all removed attachments from the Solr store.
 */
function apachesolr_attachments_cron() {
  try {
    $solr = apachesolr_get_solr();
    $result = db_query("SELECT fid, nid FROM {apachesolr_attachments_files} WHERE removed = 1");
    $ids = array();
    $fids = array();
    while ($file = db_fetch_object($result)) {
      $ids[] = 'id:'. apachesolr_document_id($file->fid .'-'. $file->nid, 'file');
      $fids[] = $file->fid;
    }
    if ($ids) {
      // TODO: use new API function.
      $solr->deleteByQuery(implode(' OR ', $ids));
      $solr->commit();
      db_query("DELETE FROM {apachesolr_attachments_files} WHERE fid IN (". db_placeholders($fids) .")", $fids);
    }
  }
  catch (Exception $e) {
    watchdog('Apache Solr Attachments', nl2br(check_plain($e->getMessage())) . ' in apachesolr_attachments_cron', NULL, WATCHDOG_ERROR);
  }
}

/**
 * Implementation of hook_apachesolr_modify_query().
 */
function apachesolr_attachments_apachesolr_modify_query(&$query, &$params, $caller) {
  // Fetch the extra file data on searches.
  if ($caller == 'apachesolr_search') {
    $params['fl'] .= ',ss_filemime,ss_file_node_title,ss_file_node_url';
  }
  elseif ($caller == 'apachesolr_mlt') {
    // Exclude files from MLT results.
    $query->add_filter('bs_file', 'true', TRUE);
  }
}

/**
 * Implementation of hook_apachesolr_process_results().
 *
 * When using the Apache Solr search module, everything is treated as a node
 * and as such values like the link and type won't be configured correctly if
 * it is a file attachement. We override such values here as needed.
 */
function apachesolr_attachments_apachesolr_process_results(&$results) {

  foreach ($results as &$item) {
    if (isset($item['node']->ss_filemime)) {
      $nid = $item['node']->nid;
      $item['link'] = file_create_url($item['node']->path);
      $node_link = t('<em>attached to:</em> !node_link', array('!node_link' => l($item['node']->ss_file_node_title, 'node/'. $nid)));
      $icon = theme('filefield_icon', array('filemime' => $item['node']->ss_filemime));
      $file_type = t('!icon @filemime', array('@filemime' => $item['node']->ss_filemime, '!icon' => $icon));
      $item['snippet'] .= '<div>' . $file_type .' '. $node_link . '</div>';
      $item['extra'] = array();
      $item['type'] = t('File attachment');
    }
  }
}

/**
 * Return all non-excluded file attachments for a particular node
 */
function _asa_get_indexable_files($node) {
  $files = array();

  if(!empty($node->files)) {
    $files = $node->files;
  }

  $fields = _asa_get_cck_file_fields();
  foreach ($fields as $field) {
    if(!empty($node->$field)) {
      $files = array_merge($files, $node->$field);
    }
  }
  $file_list = array();
  foreach ($files as $file) {
    // Some are arrays others are objects, treat them all as objects
    $file = (object) $file;
    // Some filefield-enabled nodes show up with an emtpy file array.
    if (!empty($file->fid) && apachesolr_attachments_allowed_mime($file->filemime)) {
      if (isset($file->data['description']) && !isset($file->description)) {
        $file->description = $file->data['description'];
      }
      $file_list[$file->fid] = $file;
    }
  }
  return $file_list;
}

/**
 * Return all CCK fields that are of type 'file'
 */
function _asa_get_cck_file_fields() {
  $file_fields = array();
  if(module_exists('filefield')) {
    $fields = content_fields();
    foreach($fields as $key => $values){
      if($values['type'] == 'filefield') {
        $file_fields[] = $key;
      }
    }
  }
  return $file_fields;
}

/**
 * Parse the attachment getting just the raw text.
 */
function _asa_get_attachment_text($file) {
  // Any down-side to using realpath()?
  $filepath = realpath($file->filepath);

  // No need to use java for plain text files.
  if ($file->filemime == 'text/plain' || $file->filemime == 'text/x-diff') {
    $text = file_get_contents($filepath);
    // TODO - try to detect encoding and convert to UTF-8.
    // Strip bad control characters.
    $text = iconv("UTF-8", "UTF-8//IGNORE", $text);
    $text = trim(apachesolr_clean_text($text));
    return $text;
  }

  $sha1 = sha1_file($filepath);
  if ($sha1 === FALSE) {
    return FALSE;
  }

  $cached = db_fetch_array(db_query("SELECT * FROM {apachesolr_attachments_files} WHERE fid = %d", $file->fid));

  if (!is_null($cached['body']) && ($cached['sha1'] == $sha1)) {
    // No need to re-extract.
    return $cached['body'];
  }

  if (variable_get('apachesolr_attachment_extract_using', 'tika') == 'tika') {
    $text = apachesolr_attachments_extract_using_tika($filepath);
  }
  else {
    // Extract using Solr.
    // We allow Solr to throw exceptions - they will be caught
    // by apachesolr.module.
    list($text, $metadata) = apachesolr_attachments_extract_using_solr($filepath);
  }
  // Strip bad control characters.
  $text = iconv("UTF-8", "UTF-8//IGNORE", $text);
  $text = trim(apachesolr_clean_text($text));
  // Save the extracted, cleaned text to the DB.
  db_query("UPDATE {apachesolr_attachments_files} SET sha1 = '%s', body = '%s' WHERE fid = %d", $sha1, $text, $file->fid);

  return $text;
}

/**
 * For a file path, try to extract text using a local tika jar.
 */
function apachesolr_attachments_extract_using_tika($filepath) {
  $tika_path = realpath(variable_get('apachesolr_attachments_tika_path', ''));

  $tika = $tika_path .'/'. variable_get('apachesolr_attachments_tika_jar', 'tika-0.3.jar');

  $java = variable_get('apachesolr_attachments_java', 'java');
  $cmd = escapeshellcmd($java .' -cp '. $tika_path .' -jar '. $tika .' -t "'. $filepath .'"');

  // Add a work-around for a MAMP bug.
  if (strpos(ini_get('extension_dir'), 'MAMP/')) {
    $cmd = 'export DYLD_LIBRARY_PATH=""; '. $cmd;
  }

  return shell_exec($cmd);
}

/**
 * For a file path, try to extract text using Solr 1.4.
 *
 * @throws Exception
 */
function apachesolr_attachments_extract_using_solr($filepath) {
  // Extract using Solr.
  // We allow Solr to throw exceptions - they will be caught
  // by apachesolr.module.
  $solr = apachesolr_get_solr();
  $filename = basename($filepath);
  $params = array('resource.name' => $filename);
  // Construct a multi-part form-data POST body in $data.
  $boundary = '--' . md5(uniqid(time()));
  $data = "--{$boundary}\r\n";
  // The 'filename' used here becomes the property name in the response.
  $data .= 'Content-Disposition: form-data; name="file"; filename="extracted"';
  $data .= "\r\nContent-Type: application/octet-stream\r\n\r\n";
  $data .= file_get_contents($filepath);
  $data .= "\r\n--{$boundary}--\r\n";
  $headers = array('Content-Type' => 'multipart/form-data; boundary=' . $boundary);
  $response = $solr->makeServletRequest(EXTRACTING_SERVLET, $params, 'POST', $headers, $data);
  return array($response->extracted, $response->extracted_metadata);
}

/**
 * For a particular node id, remove all file attachments from the solr index.
 */
function _asa_remove_attachments_from_index($nid) {
  try {
    $solr = apachesolr_get_solr();
    $solr->deleteByQuery("nid:{$nid} AND bs_file:true AND hash:". apachesolr_site_hash());
    $solr->commit();
  }
  catch (Exception $e) {
    watchdog('Apache Solr Attachments', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
  }
}

