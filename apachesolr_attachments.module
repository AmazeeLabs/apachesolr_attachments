<?php

/**
 * @file
 * Provides a file attachment search implementation for use with the Apache Solr module
 */

define('EXTRACTING_SERVLET', 'extract/tika');
/**
 * Implements hook_menu().
 */
function apachesolr_attachments_menu() {
  $items = array();
  $items['admin/config/search/apachesolr/attachments'] = array(
    'title' => 'Attachments',
    'description' => 'Administer Apache Solr Attachments.',
    'page callback' => 'apachesolr_attachments_admin_page',
    'access arguments' => array('administer search'),
    'file' => 'apachesolr_attachments.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/search/apachesolr/attachments/confirm/reindex'] = array(
    'title' => 'Reindex all files',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('apachesolr_attachments_confirm', 6),
    'access arguments' => array('administer search'),
    'file' => 'apachesolr_attachments.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/search/apachesolr/attachments/confirm/delete'] = array(
    'title' => 'Delete and reindex all files',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('apachesolr_attachments_confirm', 6),
    'access arguments' => array('administer search'),
    'file' => 'apachesolr_attachments.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/search/apachesolr/attachments/confirm/clear-cache'] = array(
    'title' => 'Delete the local cache of file text',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('apachesolr_attachments_confirm', 6),
    'access arguments' => array('administer search'),
    'file' => 'apachesolr_attachments.admin.inc',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * @file
 *   Indexer for the userhook_apachesolr_entity_info_alter entities for the Apachesolr module.
 */

function apachesolr_attachments_apachesolr_entity_info_alter(&$entity_info) {
  $entity_info['file']['indexable'] = TRUE;
  $entity_info['file']['status callback'][] = 'apachesolr_attachments_status_callback';
  $entity_info['file']['document callback'][] = 'apachesolr_attachments_solr_document';
  $entity_info['file']['reindex callback'] = 'apachesolr_attachments_solr_reindex';
  $entity_info['file']['index_table'] = 'apachesolr_index_entities_file';
  $entity_info['file']['result callback'] = 'apachesolr_attachments_file_result';
}

/**
 * Builds the file-specific information for a Solr document.
 *
 * @param ApacheSolrDocument $document
 *   The Solr document we are building up.
 * @param stdClass $entity
 *   The entity we are indexing.
 * @param string $entity_type
 *   The type of entity we're dealing with.
 */
function apachesolr_attachments_solr_document(ApacheSolrDocument $document, $file, $entity_type, $env_id) {
  module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
  $documents = array();

  $text = apachesolr_attachments_get_attachment_text($file);
  // Text is saved in the index table. Will be used by the node indexing if
  // available.
  // Function should exist that updates the changed data for a node when the
  // file was updated/extracted

  // Get list of nodes that are linked to this particular file
  // A single file might be attached to multiple nodes.
  $parents = file_get_file_references($file, NULL, FIELD_LOAD_CURRENT);
  $parents_list = $parents ? reset($parents) : NULL;
  if (!empty($parents_list)) {
    foreach ($parents_list as $parent_entity_type => $parent) {
      foreach ($parent as $parent_entity_id => $parent_info) {
        // load the parent entity and reset cache
        $parent_entities = entity_load($parent_entity_type, array($parent_entity_id), NULL, TRUE);
        $parent_entity = reset($parent_entities);

        // Skip invalid entities
        if (empty($parent_entity)) {
          continue;
        }

        // Retrieve the parent entity id and bundle
        list($parent_entity_id, $parent_entity_vid, $parent_entity_bundle) = entity_extract_ids($parent_entity_type, $parent_entity);

        // Get a clone of the bare minimum document
        $filedocument = clone $document;

        //Get the callback array to add stuff to the document
        $callbacks = apachesolr_entity_get_callback($parent_entity_type, 'document callback');
        // Skip invalid entity types
        if (empty($callbacks)) {
          continue;
        }

        $build_documents = array();
        foreach ($callbacks as $callback) {
          // Call a type-specific callback to add stuff to the document.
          $build_documents = array_merge($build_documents, $callback($filedocument, $parent_entity, $parent_entity_type, $env_id));
        }

        // Take the top document from the stack
        $filedocument = reset($build_documents);

        // Build our separate document and overwrite basic information
        $filedocument->id = apachesolr_document_id($file->fid . '-' . $parent_entity_type . '-' . $parent_entity_id, $entity_type);
        $filedocument->url = file_create_url($file->uri);
        $filedocument->path = file_stream_wrapper_get_instance_by_uri($file->uri)->getExternalUrl();

        // Add extra info to our document
        $filedocument->label = apachesolr_clean_text($file->filename);
        $filedocument->content = apachesolr_clean_text($file->filename) . ' ' . $text;

        $filedocument->ds_created = apachesolr_date_iso($file->timestamp);
        $filedocument->ds_changed = $filedocument->ds_created;

        $filedocument->created = apachesolr_date_iso($file->timestamp);
        $filedocument->changed = $filedocument->created;

        // Add Parent information fields. See http://drupal.org/node/1515822 for explanation
        $parent_entity_info = entity_get_info($parent_entity_type);
        $small_parent_entity = new stdClass();
        $small_parent_entity->entity_type = $parent_entity_type;
        $small_parent_entity->{$parent_entity_info['entity keys']['id']} = $parent_entity_id;
        $small_parent_entity->{$parent_entity_info['entity keys']['bundle']} = $parent_entity_bundle;
        $small_parent_entity->{$parent_entity_info['entity keys']['label']} = $parent_entity->{$parent_entity_info['entity keys']['label']};

        // Add all to one field because if it is spread out over
        // multiple fields there is no way of knowing which multifield value
        // belongs to which entity
        // It does not load the complete entity in to the index because that
        // would dramatically increase the index size and processing time
        $filedocument->zm_parent_entity = drupal_json_encode($small_parent_entity);
        $filedocument->sm_parent_entity_bundle = $parent_entity_type . "-" . $parent_entity_bundle;
        $filedocument->sm_parent_entity_type = $parent_entity_type;

        // Add Apachesolr Attachments specific fields.
        $filedocument->ss_filemime = $file->filemime;
        $filedocument->ss_filesize = $file->filesize;

        $documents[] = $filedocument;
      }
    }
  }
  return $documents;
}

/**
 * Reindexing callback for ApacheSolr, for file entities.
 */
function apachesolr_attachments_solr_reindex() {
  module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
  $indexer_table = apachesolr_get_indexer_table('file');
  $transaction = db_transaction();
  $env_id = apachesolr_default_environment();
  try {
    // Clean the table
    db_delete($indexer_table)
      ->condition('entity_type', 'file')
      ->isNull('body')
      ->execute();
    $files = _apachesolr_attachments_get_all_files();

    // If we do not have files, return success
    if (empty($files)) {
      return TRUE;
    }
    // Loop over all the files and add them to our indexing table
    foreach ($files as $parent_entity_type => $parent_entities) {
      foreach ($parent_entities as $parent_entity_id => $parent_entity_info) {
        // Fake our file class
        $file = new stdClass();
        $file->fid = $parent_entity_info->file_fid;
        apachesolr_attachments_add_file_usage($file, $parent_entity_type, $parent_entity_id);
      }
    }
  }
  catch (Exception $e) {
    $transaction->rollback();
    //drupal_set_message($e->getMessage(), 'error');
    watchdog_exception('Apache Solr Attachments', $e);
    return FALSE;
  }
  return TRUE;
}

/**
 * Fetches all files linked to nodes created by fields from the file module
 * regardless of the widget
 * @return type
 */
function _apachesolr_attachments_get_all_files() {
  $results = array();
  $fields = field_info_field_by_ids();
  foreach ($fields as $field_id => $field_info) {
    if ($field_info['type'] == 'file') {
      foreach ($field_info['bundles'] as $entity_type => $bundles) {
        $query = new ApachesolrAttachmentsEntityFieldQuery();
        $results_query = $query
          ->entityCondition('entity_type', $entity_type)
          ->fieldCondition($field_info['field_name'])
          ->addTag('apachesolr_attachments_solr_reindex')
          ->addMetaData('field_fid_key', $field_info['field_name'] . '_fid')
          ->execute();
        $results = array_merge_recursive($results, $results_query);
      }
    }
  }
  return $results;
}

/*
 * Add our file id to the result set
 */
function apachesolr_attachments_query_apachesolr_attachments_solr_reindex_alter(QueryAlterableInterface $query) {
  // We are sure that entity_id is available. Take that table and
  // add our fid key
  $fields = $query->getFields();
  $query->addField($fields['entity_id']['table'], $query->getMetaData('field_fid_key'), $query->getMetaData('field_fid_key'));
}

/**
 * Status callback for the files. Optimized so it has a quick return
 * when available
 * @param type $entity_id
 * @param type $entity_type
 * @return type
 */
function apachesolr_attachments_status_callback($entity_id, $entity_type) {
  module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
  // Make sure we have a boolean value.
  // Anything different from 1 becomes zero
  if (!$entity_id) {
    return FALSE;
  }
  // Check if the parent entity was not excluded
  if (apachesolr_attachments_excluded_entities($entity_id, $entity_type) == FALSE) {
    return FALSE;
  }

  // load the entity and reset cache
  $entities = entity_load($entity_type, array($entity_id), NULL, TRUE);
  $entity = reset($entities);

  // Check if the mimetype is allowed
  if (apachesolr_attachments_allowed_mime($entity->filemime) == FALSE) {
    return FALSE;
  }
  // Check if the entity status is active and if it is a real file
  if ($entity->status != 1) {
    return FALSE;
  }
  if (apachesolr_attachments_is_file($entity) == FALSE) {
    return FALSE;
  }

  return TRUE;
}

function apachesolr_attachments_is_file($entity) {
  if (!empty($entity->uri)) {
    $filepath = drupal_realpath($entity->uri);
    // Check that we have a valid filepath.
    if (!$filepath) {
      return FALSE;
    }
    elseif (!is_file($filepath)) {
      watchdog('Apache Solr Attachments', '%filepath is not a valid file path', array('%filepath' => $entity->uri), WATCHDOG_WARNING);
      return FALSE;
    }
    else {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Get a list of entities that are linked to this particular file
 * A single file might be attached to multiple entities.
 * Excludes a file as soon as 1 entity was excluded
 * @param type $entity_id
 * @param type $entity_type
 * @return type
 */
function apachesolr_attachments_excluded_entities($entity_id, $entity_type) {
  $env_id = apachesolr_default_environment();
  $status = FALSE;

  $file = file_load($entity_id);
  $parents = file_get_file_references($file, NULL, FIELD_LOAD_CURRENT);
  $parents_list = $parents ? reset($parents) : NULL;

  if (!empty($parents_list)) {
    foreach ($parents_list as $parent_entity_type => $parent) {
      foreach ($parent as $parent_entity_id => $parent_info) {

        $bundles = apachesolr_get_index_bundles($env_id, $parent_entity_type);
        // Ignore this parent if the bundles to be indexed for this entity type
        // are not indexed
        if (empty($bundles)) {
          continue;
        }
        else if (!in_array($parent_info->type, $bundles)) {
          continue;
        }

        // Skip indexing of files if the node was excluded by apache solr
        $status_callbacks = apachesolr_entity_get_callback($parent_entity_type, 'status callback');
        if (!empty($status_callbacks)) {
          // Set status to true. Allow the callbacks to make the change
          $status = TRUE;
          // Check status callback before sending to the index
          foreach ($status_callbacks as $status_callback) {
            if (is_callable($status_callback)) {
              // by placing $status in front we prevent calling any other callback
              // after one status callback returned false
              $status = $status && $status_callback($parent_entity_id, $parent_entity_type);
            }
          }
        }
      }
    }
  }
  // Delete the entity from our index if the status callback returns 0
  if ($status == FALSE) {
    apachesolr_remove_entity($env_id, $entity_type, $entity_id);
  }
  return $status;
}

/**
 * For a particular entity, remove all file attachments from the Solr index.
 * This function is not in use in the module but can come in handy for people
 * that prefer to use functions
 *
 * @see apachesolr_delete_node_from_index()
 */
function apachesolr_attachments_remove_attachments_from_index($parent_entity_type, $parent_entity) {
  static $failed = FALSE;
  if ($failed) {
    return FALSE;
  }
  try {
    // Retrieve the parent entity id and bundle
    list($parent_entity_id, $parent_entity_vid, $parent_entity_bundle) = entity_extract_ids($parent_entity_type, $parent_entity);
    $solr = apachesolr_get_solr();
    $solr->deleteByQuery("sm_parent_entity:{$parent_entity_type}-{$parent_entity_bundle}-{$parent_entity_id} AND entity_type:file AND hash:" . apachesolr_site_hash());
    $solr->commit();
    return TRUE;
  }
  catch (Exception $e) {
    watchdog('Apache Solr Attachments', nl2br(check_plain($e->getMessage())), NULL, WATCHDOG_ERROR);
    // Don't keep trying queries if they are failing.
    $failed = TRUE;
    return FALSE;
  }
}

/**
 * Implements hook_apachesolr_query_alter().
 */
function apachesolr_attachments_apachesolr_query_alter(DrupalSolrQueryInterface $query) {
  if ($query->getName() == 'apachesolr') {
    // Fetch the extra file data on searches.
    $query->addParam('fl', array('zm_parent_entity', 'ss_filemime', 'ss_file_entity_title', 'ss_file_entity_url'));
  }
  elseif ($query->getName() == 'apachesolr_mlt') {
    // Exclude files from MLT results.
    $query->addFilter('entity_type', 'file', TRUE);
  }
}

/*
 * hook_entity_OP functions need to happen to clean up the table after files
 * were added to the index table
 */
function apachesolr_attachments_entity_update($entity, $type) {
  module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
  apachesolr_attachments_clean_index_table();
}

function apachesolr_attachments_entity_insert($entity, $type) {
  apachesolr_attachments_entity_update($entity, $type);
}

function apachesolr_attachments_entity_delete($entity, $type) {
  module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');
  apachesolr_attachments_clean_index_table();
}

/**
 * Hook into the field operations
 *   - we want to save the same data in a shadow copy table for easier indexing.
 *   - We do not delete the file / media entity when its usage count goes to 0
 *     but instead we set status to  0.
 *   - This is meant to make the backport to drupal 6 easier
 */
function apachesolr_attachments_field_attach_insert($parent_entity_type, $parent_entity) {
  apachesolr_attachments_field_attach_update($parent_entity_type, $parent_entity);
}

function apachesolr_attachments_field_attach_update($parent_entity_type, $parent_entity) {
  foreach (field_info_instances($parent_entity_type, $parent_entity->type) as $instance) {
    $field_info = field_info_field($instance['field_name']);
    if ($field_info['type'] == 'file') {
      // Include the file after the if, otherwise it'll get included everywhere
      module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');

      $items = field_get_items($parent_entity_type, $parent_entity, $field_info['field_name']);
      foreach ($items as $file_info) {
        $file = file_load($file_info['fid']);
        // Discard empty entities
        if (empty($file)) {
          continue;
        }
        // Retrieve parent entity id and add its file usage
        list($parent_entity_id) = entity_extract_ids($parent_entity_type, $parent_entity);
        apachesolr_attachments_add_file_usage($file, $parent_entity_type, $parent_entity_id);
      }
    }
  }
}

function apachesolr_attachments_field_attach_delete($parent_entity_type, $parent_entity) {
  foreach (field_info_instances($parent_entity_type, $parent_entity->type) as $instance) {
    $field_info = field_info_field($instance['field_name']);
    if ($field_info['type'] == 'file') {
      // Include the file after the if, otherwise it'll get included everywhere
      module_load_include('inc', 'apachesolr_attachments', 'apachesolr_attachments.index');

      $items = field_get_items($parent_entity_type, $parent_entity, $field_info['field_name']);
      foreach ($items as $file_info) {
        $file = file_load($file_info['fid']);
        // Discard empty entities
        if (empty($file)) {
          continue;
        }
        // Retrieve parent entity id and delete its file usage
        list($parent_entity_id) = entity_extract_ids($parent_entity_type, $parent_entity);
        apachesolr_attachments_delete_file_usage($file, $parent_entity_type, $parent_entity_id);
      }
    }
  }
}

/**
 * Callback function for file search results.
 *
 * @param stdClass $doc
 *   The result document from Apache Solr.
 * @param array $result
 *   The result array for this record to which to add.
 */
function apachesolr_attachments_file_result($doc, &$result, &$extra) {
  $doc->uid = $doc->is_uid;
  $result += array(
    'type' => t('File attachment'),
    'user' => theme('username', array('account' => $doc)),
    'date' => isset($doc->created) ? $doc->created : 0,
    'node' => $doc,
    'file' => $doc,
    'uid' => $doc->is_uid,
  );
}

/**
 * Implements hook_theme().
 */
function apachesolr_attachments_theme() {
  return array(
    'apachesolr_search_snippets__file' => array(
      'variables' => array('doc' => NULL, 'snippets' => array()),
    ),
  );
}


/**
 * @todo Vastly improve this theming function
 * @param type $vars
 * @return type
 */
function theme_apachesolr_search_snippets__file($vars) {
  $doc = $vars['doc'];
  $snippets = $vars['snippets'];
  $parent_entity_links = array();

  // Retrieve our parent entities. They have been saved as
  // a small serialized entity
  foreach ($doc->zm_parent_entity as $parent_entity_encoded) {
    $parent_entity = (object) drupal_json_decode($parent_entity_encoded);
    $parent_entity_uri = entity_uri($parent_entity->entity_type, $parent_entity);
    $parent_entity_uri['options']['absolute'] = TRUE;
    $parent_label = entity_label($parent_entity->entity_type, $parent_entity);
    $parent_entity_links[] = l($parent_label, $parent_entity_uri['path'], $parent_entity_uri['options']);
  }

  if (module_exists('file')) {
    $file_type = t('!icon @filemime', array('@filemime' => $doc->ss_filemime, '!icon' => theme('file_icon', array('file' => (object) array('filemime' => $doc->ss_filemime)))));
  }
  else {
    $file_type = t('@filemime', array('@filemime' => $doc->ss_filemime));
  }

  return implode(' ... ', $snippets) . '<span>' . $file_type . ' <em>attached to:</em>' . implode(', ', $parent_entity_links) . '</span>';
}

/**
 * Provides a default list of filename extensions to exclude from the index.
 *
 * @return
 *   An array of file extensions.
 */
function apachesolr_attachments_default_excluded() {
  $default = array('aif', 'art', 'avi', 'bmp', 'gif', 'ico', 'jpg', 'mov', 'mp3', 'mp4', 'mpg', 'oga', 'ogv', 'png', 'psd', 'ra', 'ram', 'rgb', 'tif');
  return $default;
}



class ApachesolrAttachmentsEntityFieldQuery extends EntityFieldQuery {
 /**
  * Finishes the query.
  *
  * Adds tags, metaData, range and returns the requested list or count.
  *
  * @param SelectQuery $select_query
  *   A SelectQuery which has entity_type, entity_id, revision_id and bundle
  *   fields added.
  * @param $id_key
  *   Which field's values to use as the returned array keys.
  *
  * @return
  *   See EntityFieldQuery::execute().
  */
  function finishQuery($select_query, $id_key = 'entity_id') {
    foreach ($this->tags as $tag) {
      $select_query->addTag($tag);
    }
    foreach ($this->metaData as $key => $object) {
      $select_query->addMetaData($key, $object);
    }
    $select_query->addMetaData('entity_field_query', $this);
    if ($this->range) {
      $select_query->range($this->range['start'], $this->range['length']);
    }
    if ($this->count) {
      return $select_query->countQuery()->execute()->fetchField();
    }
    $return = array();
    foreach ($select_query->execute() as $partial_entity) {
      $bundle = isset($partial_entity->bundle) ? $partial_entity->bundle : NULL;
      $entity = entity_create_stub_entity($partial_entity->entity_type, array($partial_entity->entity_id, $partial_entity->revision_id, $bundle));
      // This is adding the file id using our metaData field.
      $entity->file_fid = $partial_entity->{$this->metaData['field_fid_key']};
      $return[$partial_entity->entity_type][$partial_entity->$id_key] = $entity;
      $this->ordered_results[] = $partial_entity;
    }
    return $return;
  }
}